1) Arquitectura y buenas pr√°cticas

Qu√© vamos a proteger: la ventana de Configuraci√≥n.
D√≥nde: antes de abrir config.html, mostramos un gate de login.
C√≥mo guardamos credenciales:

No almacenar contrase√±as en texto plano.

Usar Argon2id para el hash (argon2 npm).

Guardar en electron-store solo: username, passwordHash, secretPhraseHash, pol√≠ticas y estado (intentos fallidos, lockout‚Ä¶).

El Access Token de MP sigue como est√° (encriptado con electron-store); esto es independiente.

Recuperaci√≥n:

Opci√≥n A ‚Äì Frase secreta (obligatoria al crear la contrase√±a):

Guardar hash de la frase (Argon2id).

Si coincide, se permite resetear contrase√±a y (opcional) usuario.

Opci√≥n B ‚Äì Email (si est√° configurado el SMTP):

Enviar c√≥digo OTP (6 d√≠gitos, vence en 10 min).

Validar y permitir el reset.

Endurecimiento:

Pol√≠tica: min 8‚Äì10 caracteres, 1 may√∫scula, 1 n√∫mero.

Rate-limit/lockout: p.ej. bloqueo 5 min tras 5 intentos fallidos.

Throttling de verificaci√≥n (100‚Äì250 ms) para evitar ataques de tiempo.

IPC s√≥lo desde renderer confiable (origin check).

Auditor√≠a: loggear intentos y resets (sin datos sensibles).



Act√∫a como dev senior de Electron + TypeScript. Agrega autenticaci√≥n de ‚ÄúModo Administrador‚Äù sin romper la l√≥gica actual.

Contexto:
- App Electron TS con dos vistas: caja.html (operativa) y config.html (administraci√≥n).
- electron-store ya est√° integrado.
- Tailwind en UI.
- SMTP opcional ya existe para reportes.

Objetivo:
1) Gate de login al abrir config.html:
   - Si no hay credenciales iniciales -> flujo de ‚ÄúSetup Admin‚Äù (crear usuario/contrase√±a + definir FRase Secreta).
   - Si ya hay credenciales -> pedir usuario + contrase√±a.

2) Recuperaci√≥n:
   - Opci√≥n A: ‚ÄúTengo frase secreta‚Äù -> si coincide (hash Argon2id), permitir reset de contrase√±a y (opcional) usuario.
   - Opci√≥n B: ‚ÄúEnviar c√≥digo por email‚Äù -> si hay SMTP configurado, generar OTP 6 d√≠gitos (vence en 10 minutos), enviar y validar.

3) Seguridad:
   - Hash Argon2id para password y secret phrase (paquetes `argon2`).
   - Pol√≠tica: minLength=8, debe tener n√∫mero y may√∫scula.
   - Rate-limit: max 5 intentos/15 min; si supera, lockout 5 min.
   - Throttle de verificaci√≥n 150ms.
   - No guardar contrase√±as en claro ni en memoria m√°s de lo necesario.
   - Logs sin datos sensibles.

4) IPC (main.ts):
   - `auth:is-initialized` -> bool
   - `auth:setup({username, password, secretPhrase})`
   - `auth:login({username, password})` -> success / lockout data
   - `auth:logout()`
   - `auth:request-otp()` -> si SMTP, enviar; devolver masked email y ttl
   - `auth:reset-by-otp({otp, newPassword, newUsername?})`
   - `auth:reset-by-secret({secretPhrase, newPassword, newUsername?})`
   - `auth:get-policy()` -> {minLength, requiresNumber, requiresUpper, maxAttempts, lockoutMinutes}
   - Persistir en electron-store:
     auth: {
       username: string,
       passwordHash: string,
       secretPhraseHash: string,
       failedCount: number,
       lockedUntil?: number
     }

5) Preload (exponer en `window.auth`):
   - M√©todos arriba. Validar origin; no exponer electron-store directo.

6) UI:
   - Crear `public/auth.html` (dark, Tailwind):
     - Vista ‚ÄúLogin‚Äù con link ‚Äú¬øOlvidaste tu contrase√±a?‚Äù.
     - Vista ‚ÄúSetup Admin‚Äù (si no inicializado).
     - Vista ‚ÄúRecuperar‚Äù: tabs ‚ÄúFrase secreta‚Äù y ‚ÄúEmail‚Äù.
   - En `main.ts`, al elegir Configuraci√≥n desde caja.html -> abrir `auth.html`.
     - Si login OK, entonces abrir `config.html` y cerrar `auth.html`.
   - En `config.html`, agregar secci√≥n ‚ÄúSeguridad‚Äù para cambiar contrase√±a/usuario (pide password actual + nueva + confirmar y opcionalmente actualizar frase secreta).

7) Aceptaci√≥n:
   - Primer arranque: pide Setup Admin, luego permite entrar.
   - Login con usuario/contrase√±a. Lockout tras 5 fallos/15 min.
   - Recuperaci√≥n por frase secreta y por email (si SMTP).
   - Cambiar usuario/contrase√±a desde ‚ÄúSeguridad‚Äù solicitando password actual.
   - No se altera l√≥gica de Mercado Pago ni automatizaci√≥n.

Entrega:
- Nuevos archivos: `src/services/AuthService.ts`, `public/auth.html`, `src/auth.ts` (renderer), updates en `src/main.ts`, `src/preload.ts`.
- C√≥digo TS comentado, sin romper build ni flujos existentes.


Snippets clave (listos para pegar)

AuthService.ts (n√∫cleo)


Snippets clave (listos para pegar)

AuthService.ts (n√∫cleo)

// src/services/AuthService.ts
import Store from 'electron-store';
import argon2 from 'argon2';

type AuthState = {
  username?: string;
  passwordHash?: string;
  secretPhraseHash?: string;
  failedCount?: number;
  lockedUntil?: number;
};

const store = new Store<{ auth: AuthState }>();

const POLICY = {
  minLength: 8,
  requiresNumber: true,
  requiresUpper: true,
  maxAttempts: 5,
  lockoutMinutes: 5,
  throttleMs: 150
};

function passwordValid(pw: string) {
  if (pw.length < POLICY.minLength) return false;
  if (POLICY.requiresNumber && !/\d/.test(pw)) return false;
  if (POLICY.requiresUpper && !/[A-Z]/.test(pw)) return false;
  return true;
}

export const AuthService = {
  isInitialized(): boolean {
    const a = store.get('auth') || {};
    return Boolean(a.username && a.passwordHash && a.secretPhraseHash);
  },

  policy() { return POLICY; },

  async setup(username: string, password: string, secretPhrase: string) {
    if (!passwordValid(password)) throw new Error('weak_password');
    const passwordHash = await argon2.hash(password, { type: argon2.argon2id });
    const secretPhraseHash = await argon2.hash(secretPhrase, { type: argon2.argon2id });
    store.set('auth', { username, passwordHash, secretPhraseHash, failedCount: 0, lockedUntil: 0 });
  },

  async login(username: string, password: string) {
    await new Promise(r => setTimeout(r, POLICY.throttleMs));
    const a = store.get('auth') || {};
    const now = Date.now();
    if (a.lockedUntil && now < a.lockedUntil) {
      return { ok: false, reason: 'locked', unlockAt: a.lockedUntil };
    }
    if (!a.username || !a.passwordHash) return { ok: false, reason: 'not_initialized' };
    const userOk = username === a.username;
    const passOk = userOk ? await argon2.verify(a.passwordHash!, password) : false;

    if (!userOk || !passOk) {
      const failed = (a.failedCount ?? 0) + 1;
      const lock = failed >= POLICY.maxAttempts ? now + POLICY.lockoutMinutes * 60_000 : 0;
      store.set('auth', { ...a, failedCount: lock ? 0 : failed, lockedUntil: lock || 0 });
      return { ok: false, reason: lock ? 'locked' : 'invalid' };
    }
    store.set('auth', { ...a, failedCount: 0, lockedUntil: 0 });
    return { ok: true };
  },

  async changePassword(currentPw: string, newPw: string, newUsername?: string, newSecretPhrase?: string) {
    const a = store.get('auth') || {};
    if (!a.passwordHash) throw new Error('not_initialized');
    const ok = await argon2.verify(a.passwordHash, currentPw);
    if (!ok) throw new Error('invalid_current');
    if (!passwordValid(newPw)) throw new Error('weak_password');

    const passwordHash = await argon2.hash(newPw, { type: argon2.argon2id });
    const secretPhraseHash = newSecretPhrase
      ? await argon2.hash(newSecretPhrase, { type: argon2.argon2id })
      : a.secretPhraseHash;

    store.set('auth', {
      ...a,
      username: newUsername || a.username,
      passwordHash,
      secretPhraseHash
    });
  },

  async resetBySecret(secretPhrase: string, newPw: string, newUsername?: string) {
    const a = store.get('auth') || {};
    if (!a.secretPhraseHash) throw new Error('not_initialized');
    const ok = await argon2.verify(a.secretPhraseHash, secretPhrase);
    if (!ok) throw new Error('invalid_secret');
    if (!passwordValid(newPw)) throw new Error('weak_password');
    const passwordHash = await argon2.hash(newPw, { type: argon2.argon2id });
    store.set('auth', { ...a, username: newUsername || a.username, passwordHash });
  }
};


OTP simple (si hay SMTP)

// src/services/OtpService.ts
import Store from 'electron-store';
import crypto from 'crypto';
import { EmailService } from './EmailService'; // ya lo ten√©s

const store = new Store<{ otp?: { code: string, expiresAt: number, masked: string } }>();

export const OtpService = {
  createAndSend(toEmail: string) {
    const code = ('' + Math.floor(100000 + Math.random()*900000)).slice(-6);
    const expiresAt = Date.now() + 10 * 60_000; // 10 min
    const masked = toEmail.replace(/(.{2}).+(@.+)/, '$1***$2');
    store.set('otp', { code, expiresAt, masked });
    EmailService.send({
      to: toEmail,
      subject: 'C√≥digo de recuperaci√≥n',
      text: `Tu c√≥digo es ${code}. Vence en 10 minutos.`
    });
    return { masked, ttl: 600 };
  },
  validate(code: string) {
    const otp = store.get('otp');
    const ok = otp && otp.code === code && Date.now() < otp.expiresAt;
    if (ok) store.delete('otp');
    return Boolean(ok);
  }
};

IPC en main.ts (resumen)

// src/main.ts (fragmentos)
import { ipcMain } from 'electron';
import { AuthService } from './services/AuthService';
import { OtpService } from './services/OtpService';

ipcMain.handle('auth:is-initialized', () => AuthService.isInitialized());
ipcMain.handle('auth:get-policy', () => AuthService.policy());
ipcMain.handle('auth:setup', (_e, p) => AuthService.setup(p.username, p.password, p.secretPhrase));
ipcMain.handle('auth:login', (_e, p) => AuthService.login(p.username, p.password));
ipcMain.handle('auth:change', (_e, p) => AuthService.changePassword(p.current, p.newPw, p.newUser, p.newSecret));
ipcMain.handle('auth:reset-by-secret', (_e, p) => AuthService.resetBySecret(p.secretPhrase, p.newPw, p.newUser));
ipcMain.handle('auth:request-otp', () => {
  // obtener email desde config SMTP (si ten√©s EMAIL_REPORT u otro)
  const email = /* leer de store */;
  if (!email) throw new Error('no_email');
  return OtpService.createAndSend(email);
});
ipcMain.handle('auth:reset-by-otp', (_e, p) => {
  if (!OtpService.validate(p.otp)) throw new Error('invalid_otp');
  return AuthService.changePassword(p.current ?? '', p.newPw, p.newUser); // current puede omitirse en reset
});


Preload

// src/preload.ts (fragmento)
import { contextBridge, ipcRenderer } from 'electron';
contextBridge.exposeInMainWorld('auth', {
  isInitialized: () => ipcRenderer.invoke('auth:is-initialized'),
  getPolicy:     () => ipcRenderer.invoke('auth:get-policy'),
  setup:         (p:any) => ipcRenderer.invoke('auth:setup', p),
  login:         (p:any) => ipcRenderer.invoke('auth:login', p),
  change:        (p:any) => ipcRenderer.invoke('auth:change', p),
  requestOtp:    () => ipcRenderer.invoke('auth:request-otp'),
  resetByOtp:    (p:any) => ipcRenderer.invoke('auth:reset-by-otp', p),
  resetBySecret: (p:any) => ipcRenderer.invoke('auth:reset-by-secret', p),
});



Flow de ventanas

Desde Modo Caja ‚Üí ‚ÄúConfiguraci√≥n‚Äù: abrir auth.html.

En auth.html:

Si auth.isInitialized() == false ‚Üí mostrar Setup.

Si true ‚Üí mostrar Login.

Si login OK ‚Üí cerrar auth.html y abrir config.html.


hecklist de pruebas

 Primer arranque sin credenciales ‚Üí aparece Setup Admin.

 Crear usuario/contrase√±a/frasesecreta ‚Üí login OK.

 Pol√≠tica de password se aplica y bloquea d√©biles.

 5 intentos fallidos ‚Üí lockout 5 min.

 ‚Äú¬øOlvidaste tu contrase√±a?‚Äù ‚Üí

 Frase secreta v√°lida permite resetear.

 OTP por email (si SMTP) v√°lido permite resetear.

 Cambiar usuario/contrase√±a desde ‚ÄúSeguridad‚Äù (pide password actual).

 Logs registran intentos (sin datos sensibles).

 No se puede abrir config.html sin pasar por auth.html.

 Automatizaci√≥n, reportes y resto de funciones siguen OK.



-------------
auth.html listo para tu proyecto con 3 vistas integradas:

Login

Setup Admin (primer arranque)

Recuperaci√≥n (Frase secreta y Email OTP)

Incluye dise√±o Tailwind en modo oscuro, botones claros y placeholders para que enganches tu l√≥gica ya expuesta en window.auth.


public/auth.html

<!DOCTYPE html>
<html lang="es" class="h-full bg-gray-900">
<head>
  <meta charset="UTF-8">
  <title>Acceso Administrador</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="h-full flex items-center justify-center text-white">

<div id="app" class="w-full max-w-md p-6 bg-gray-800 rounded-xl shadow-lg space-y-4">

  <!-- HEADER -->
  <div class="text-center">
    <h1 id="form-title" class="text-2xl font-bold">Modo Administrador</h1>
    <p id="form-subtitle" class="text-gray-400 text-sm">Ingrese sus credenciales</p>
  </div>

  <!-- LOGIN FORM -->
  <form id="login-form" class="space-y-4">
    <input type="text" id="login-user" placeholder="Usuario"
           class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600 focus:outline-none focus:ring focus:border-blue-400">
    <input type="password" id="login-pass" placeholder="Contrase√±a"
           class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600 focus:outline-none focus:ring focus:border-blue-400">
    <button type="submit" class="w-full py-2 bg-blue-600 rounded hover:bg-blue-700 font-semibold">Ingresar</button>
    <div class="text-sm text-center">
      <a href="#" id="forgot-link" class="text-blue-400 hover:underline">¬øOlvidaste tu contrase√±a?</a>
    </div>
  </form>

  <!-- SETUP FORM -->
  <form id="setup-form" class="space-y-4 hidden">
    <input type="text" id="setup-user" placeholder="Nuevo usuario"
           class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
    <input type="password" id="setup-pass" placeholder="Nueva contrase√±a"
           class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
    <input type="text" id="setup-secret" placeholder="Frase secreta (recuperaci√≥n)"
           class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
    <button type="submit" class="w-full py-2 bg-green-600 rounded hover:bg-green-700 font-semibold">Crear Admin</button>
  </form>

  <!-- RECOVERY FORM -->
  <div id="recovery-form" class="hidden space-y-4">
    <div class="flex space-x-2 justify-center mb-4">
      <button id="tab-secret" class="px-3 py-1 bg-blue-600 rounded">Frase Secreta</button>
      <button id="tab-email" class="px-3 py-1 bg-gray-700 rounded">Email OTP</button>
    </div>

    <!-- SECRET -->
    <div id="rec-secret" class="space-y-3">
      <input type="text" id="rec-secret-input" placeholder="Frase secreta"
             class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
      <input type="password" id="rec-secret-newpass" placeholder="Nueva contrase√±a"
             class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
      <button id="btn-secret-reset" class="w-full py-2 bg-green-600 rounded">Resetear</button>
    </div>

    <!-- EMAIL -->
    <div id="rec-email" class="hidden space-y-3">
      <button id="btn-send-otp" class="w-full py-2 bg-blue-600 rounded">Enviar c√≥digo al email</button>
      <input type="text" id="rec-email-otp" placeholder="C√≥digo recibido"
             class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
      <input type="password" id="rec-email-newpass" placeholder="Nueva contrase√±a"
             class="w-full px-3 py-2 rounded bg-gray-700 border border-gray-600">
      <button id="btn-email-reset" class="w-full py-2 bg-green-600 rounded">Resetear</button>
    </div>

    <div class="text-sm text-center">
      <a href="#" id="back-login" class="text-blue-400 hover:underline">Volver al login</a>
    </div>
  </div>

</div>

<script>
(async () => {
  const loginForm = document.getElementById('login-form');
  const setupForm = document.getElementById('setup-form');
  const recoveryForm = document.getElementById('recovery-form');
  const title = document.getElementById('form-title');
  const subtitle = document.getElementById('form-subtitle');

  const isInit = await window.auth.isInitialized();
  if (!isInit) {
    loginForm.classList.add('hidden');
    setupForm.classList.remove('hidden');
    title.textContent = 'Configurar Administrador';
    subtitle.textContent = 'Cree el usuario y contrase√±a';
  }

  loginForm.addEventListener('submit', async e => {
    e.preventDefault();
    const u = document.getElementById('login-user').value.trim();
    const p = document.getElementById('login-pass').value.trim();
    const res = await window.auth.login({ username: u, password: p });
    if (res.ok) {
      window.location.href = 'config.html';
    } else {
      alert('Error: ' + res.reason);
    }
  });

  setupForm.addEventListener('submit', async e => {
    e.preventDefault();
    const u = document.getElementById('setup-user').value.trim();
    const p = document.getElementById('setup-pass').value.trim();
    const s = document.getElementById('setup-secret').value.trim();
    try {
      await window.auth.setup({ username: u, password: p, secretPhrase: s });
      alert('Administrador creado. Ahora puede iniciar sesi√≥n.');
      window.location.reload();
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });

  // Recuperaci√≥n
  document.getElementById('forgot-link').addEventListener('click', e => {
    e.preventDefault();
    loginForm.classList.add('hidden');
    recoveryForm.classList.remove('hidden');
    title.textContent = 'Recuperar Acceso';
    subtitle.textContent = '';
  });

  document.getElementById('back-login').addEventListener('click', e => {
    e.preventDefault();
    recoveryForm.classList.add('hidden');
    loginForm.classList.remove('hidden');
    title.textContent = 'Modo Administrador';
    subtitle.textContent = 'Ingrese sus credenciales';
  });

  // Tabs
  document.getElementById('tab-secret').addEventListener('click', () => {
    document.getElementById('rec-secret').classList.remove('hidden');
    document.getElementById('rec-email').classList.add('hidden');
  });
  document.getElementById('tab-email').addEventListener('click', () => {
    document.getElementById('rec-secret').classList.add('hidden');
    document.getElementById('rec-email').classList.remove('hidden');
  });

  // Reset por frase
  document.getElementById('btn-secret-reset').addEventListener('click', async () => {
    const s = document.getElementById('rec-secret-input').value.trim();
    const np = document.getElementById('rec-secret-newpass').value.trim();
    try {
      await window.auth.resetBySecret({ secretPhrase: s, newPw: np });
      alert('Contrase√±a cambiada.');
      window.location.reload();
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });

  // Email OTP
  document.getElementById('btn-send-otp').addEventListener('click', async () => {
    try {
      const res = await window.auth.requestOtp();
      alert('C√≥digo enviado a: ' + res.masked);
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });

  document.getElementById('btn-email-reset').addEventListener('click', async () => {
    const otp = document.getElementById('rec-email-otp').value.trim();
    const np = document.getElementById('rec-email-newpass').value.trim();
    try {
      await window.auth.resetByOtp({ otp, newPw: np });
      alert('Contrase√±a cambiada.');
      window.location.reload();
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });

})();
</script>
</body>
</html>



C√≥mo integrarlo

Guardar como public/auth.html

Asegurarte que en main.ts, cuando el usuario pulse ‚ÄúConfiguraci√≥n‚Äù desde Modo Caja, abra primero esta p√°gina (auth.html) y no directamente config.html.

Si login OK ‚Üí abrir config.html.

Este HTML ya llama a:

window.auth.isInitialized()

window.auth.login(...)

window.auth.setup(...)

window.auth.resetBySecret(...)

window.auth.requestOtp()

window.auth.resetByOtp(...)


Te voy a dejar el flujo listo para que el auth.html que te prepar√© funcione sin romper nada y enganche con tu sistema actual en Electron + Node.js.

preload.ts

Vamos a exponer las funciones window.auth que el HTML usa.


// preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('auth', {
  isInitialized: () => ipcRenderer.invoke('auth:isInitialized'),
  login: (creds: { username: string; password: string }) => ipcRenderer.invoke('auth:login', creds),
  setup: (data: { username: string; password: string; secretPhrase: string }) => ipcRenderer.invoke('auth:setup', data),
  resetBySecret: (data: { secretPhrase: string; newPw: string }) => ipcRenderer.invoke('auth:resetBySecret', data),
  requestOtp: () => ipcRenderer.invoke('auth:requestOtp'),
  resetByOtp: (data: { otp: string; newPw: string }) => ipcRenderer.invoke('auth:resetByOtp', data)
});


main.ts

En main.ts vamos a manejar la l√≥gica de autenticaci√≥n y almacenamiento seguro.

import { app, BrowserWindow, ipcMain } from 'electron';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';

let mainWindow: BrowserWindow;
const configFile = path.join(app.getPath('userData'), 'admin-config.json');

// üîê Encriptaci√≥n de contrase√±as
function hashPass(pass: string) {
  return crypto.createHash('sha256').update(pass).digest('hex');
}

// üì¶ Cargar config
function loadConfig() {
  if (!fs.existsSync(configFile)) return null;
  return JSON.parse(fs.readFileSync(configFile, 'utf8'));
}

// üíæ Guardar config
function saveConfig(cfg: any) {
  fs.writeFileSync(configFile, JSON.stringify(cfg, null, 2));
}

// ‚úÖ Inicializaci√≥n
ipcMain.handle('auth:isInitialized', () => {
  return fs.existsSync(configFile);
});

// üîë Login
ipcMain.handle('auth:login', (e, { username, password }) => {
  const cfg = loadConfig();
  if (!cfg) return { ok: false, reason: 'No configurado' };
  if (cfg.username === username && cfg.password === hashPass(password)) {
    return { ok: true };
  }
  return { ok: false, reason: 'Usuario o contrase√±a inv√°lidos' };
});

// üÜï Setup
ipcMain.handle('auth:setup', (e, { username, password, secretPhrase }) => {
  const cfg = { username, password: hashPass(password), secretPhrase, email: null };
  saveConfig(cfg);
  return true;
});

// üîÑ Reset por frase secreta
ipcMain.handle('auth:resetBySecret', (e, { secretPhrase, newPw }) => {
  const cfg = loadConfig();
  if (!cfg) throw new Error('No configurado');
  if (cfg.secretPhrase !== secretPhrase) throw new Error('Frase secreta incorrecta');
  cfg.password = hashPass(newPw);
  saveConfig(cfg);
  return true;
});

// üìß Env√≠o OTP (simulado, aqu√≠ puedes conectar SMTP real)
let otpCode: string | null = null;
ipcMain.handle('auth:requestOtp', () => {
  const cfg = loadConfig();
  if (!cfg || !cfg.email) throw new Error('Email no configurado');
  otpCode = Math.floor(100000 + Math.random() * 900000).toString();
  console.log(`üîê OTP enviado a ${cfg.email}: ${otpCode}`); // Aqu√≠ integrar con nodemailer
  return { masked: cfg.email.replace(/(.{2}).+(@.+)/, '$1****$2') };
});

// üîÑ Reset por OTP
ipcMain.handle('auth:resetByOtp', (e, { otp, newPw }) => {
  if (!otpCode || otp !== otpCode) throw new Error('C√≥digo incorrecto');
  const cfg = loadConfig();
  if (!cfg) throw new Error('No configurado');
  cfg.password = hashPass(newPw);
  saveConfig(cfg);
  otpCode = null;
  return true;
});

// üñ• Crear ventana principal
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 700,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  // Siempre iniciar en auth.html
  mainWindow.loadFile(path.join(__dirname, '../public/auth.html'));
}

app.whenReady().then(createWindow);



3Ô∏è‚É£ Flujo de uso

Primer arranque ‚Üí auth.html detecta que no existe config ‚Üí muestra formulario de Setup.

Login correcto ‚Üí redirige a config.html (modo administrador).

Olvid√© la contrase√±a ‚Üí pesta√±a de recuperaci√≥n por frase secreta o email OTP.

Usuario y contrase√±a ‚Üí almacenados encriptados con SHA256.

Archivo de config ‚Üí guardado en userData de Electron (aislado por usuario/SO).

4Ô∏è‚É£ Siguientes mejoras opcionales

Integrar Nodemailer para enviar OTP real por SMTP.

A√±adir limitador de intentos para evitar ataques de fuerza bruta.

Cifrar tambi√©n la frase secreta en el archivo.

Posibilidad de cambiar usuario y correo desde el modo administrador.

