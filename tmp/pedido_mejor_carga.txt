Objetivo

Agregar una pol√≠tica de conflicto seleccionable:

Omitir (no sobreescribe)

Sobrescribir (comportamiento actual)

Sumar siguiente n√∫mero (genera nombres continuando la secuencia existente en destino).

Agregar bot√≥n ‚ÄúVer‚Äù (a la izquierda de Anular) que muestre (en un modal simple) los archivos que ya existen en cada URI y abro carpeta.

1) Main (IPC nuevos) ‚Äì src/main/windows/cargaWindow.ts

Agregar handlers para:

carga:list-matching ‚Üí devolver archivos que coinciden con NOMBRE(-N).EXT por URI.

carga:get-next-index ‚Üí devolver m√°ximo sufijo + 1 entre todas las URIs.

carga:open-folder ‚Üí abrir carpeta en el Explorador.

Extender el IPC carga:process para aceptar { files, mode } donde mode es 'overwrite' | 'skip'.

// imports existentes‚Ä¶
import { ipcMain, shell } from "electron";
import fs from "fs/promises";
import fssync from "fs";
import path from "path";

// util local
function escapeRegExp(s:string){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

ipcMain.handle("carga:list-matching", async (_e, payload: { uris:string[]; base:string; ext:string })=>{
  const { uris, base, ext } = payload;
  const rx = new RegExp(`^${escapeRegExp(base)}(?:-(\\d+))?\\.${escapeRegExp(ext)}$`, "i");

  const results = await Promise.all(uris.map(async (dir) => {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      const files = entries.filter(d => d.isFile() && rx.test(d.name)).map(d => d.name);
      let max = 0;
      for (const name of files) {
        const m = rx.exec(name);
        const n = m && m[1] ? parseInt(m[1], 10) : 0;
        if (n > max) max = n;
      }
      return { dir, exists: true, files, maxSuffix: max };
    } catch (err:any) {
      // no existe o no accesible
      return { dir, exists: false, files: [], maxSuffix: -1, error: err?.message || String(err) };
    }
  }));

  return results;
});

ipcMain.handle("carga:get-next-index", async (_e, payload: { uris:string[]; base:string; ext:string })=>{
  const res:any[] = await (ipcMain as any).handle("carga:list-matching", _e, payload); // reuse handler
  // si handle indirecto no funciona, repetir l√≥gica aqu√≠ (aceptable).
  const max = res.reduce((m, r) => Math.max(m, r.maxSuffix ?? -1), -1);
  // si no hay archivos, nextIndex = 0 (para permitir base sin sufijo)
  const nextIndex = Math.max(0, max + 1);
  return { nextIndex, byUri: res };
});

ipcMain.handle("carga:open-folder", async (_e, dir: string) => {
  try {
    if (fssync.existsSync(dir)) {
      await shell.openPath(dir);
      return { ok: true };
    }
    return { ok: false, message: "El directorio no existe." };
  } catch (e:any) {
    return { ok: false, message: e?.message || String(e) };
  }
});

// ‚ö†Ô∏è Actualizar el IPC de procesado para recibir 'mode'
ipcMain.once("carga:process", async (event, payload: { files: { realPath:string; targetName:string }[]; mode: "overwrite"|"skip" }) => {
  try {
    const { processFilesToUris } = await import("../../services/carga/CargaProcessor");
    await processFilesToUris(payload.files, opts.parsed.uris, payload.mode);
    try { await fs.unlink(opts.txtPath); } catch {}
    event.reply("carga:done", { ok: true, ms: 2000 });
  } catch (err: any) {
    event.reply("carga:error", { message: err?.message || String(err) });
  }
});


Nota: si prefer√≠s no ‚Äúreusar‚Äù el handler dentro de otro, copi√° la mini-l√≥gica de get-next-index (id√©ntico resultado).

2) Processor con mode ‚Äì src/services/carga/CargaProcessor.ts

A√±adir mode 'overwrite' | 'skip' y respetarlo.

import path from "path";
import fs from "fs/promises";

export type FileToProcess = { realPath: string; targetName: string };
export type WriteMode = "overwrite" | "skip";

async function ensureDir(dir:string){ await fs.mkdir(dir, { recursive:true }); }
async function fileExists(p:string){ try { await fs.access(p); return true; } catch { return false; } }

export async function processFilesToUris(files: FileToProcess[], uris: string[], mode: WriteMode = "overwrite") {
  for (const f of files) {
    const buf = await fs.readFile(f.realPath);
    for (const uri of uris) {
      await ensureDir(uri);
      const dest = path.join(uri, f.targetName);
      if (mode === "skip" && await fileExists(dest)) {
        // omitir si ya existe
        continue;
      }
      await fs.writeFile(dest, buf); // overwrite por defecto
    }
  }
}

3) Preload ‚Äì src/preload/carga.preload.ts

Exponer m√©todos nuevos: listMatching, getNextIndex, openFolder.

import { contextBridge, ipcRenderer } from "electron";
console.log("[carga.preload] iniciado");

contextBridge.exposeInMainWorld("CargaAPI", {
  requestInit(){ ipcRenderer.send("carga:request-init"); },
  onInit(cb:(d:any)=>void){ ipcRenderer.on("carga:init", (_e,d)=>cb(d)); },
  cancel(){ ipcRenderer.send("carga:cancel"); },
  process(payload:{files:{realPath:string;targetName:string}[]; mode:"overwrite"|"skip"}) {
    ipcRenderer.send("carga:process", payload);
  },
  onDone(cb:(p:{ok:boolean; ms:number})=>void){ ipcRenderer.on("carga:done", (_e,d)=>cb(d)); },
  onError(cb:(p:{message:string})=>void){ ipcRenderer.on("carga:error", (_e,d)=>cb(d)); },

  // NUEVO
  listMatching(uris:string[], base:string, ext:string){
    return ipcRenderer.invoke("carga:list-matching", { uris, base, ext });
  },
  getNextIndex(uris:string[], base:string, ext:string){
    return ipcRenderer.invoke("carga:get-next-index", { uris, base, ext });
  },
  openFolder(dir:string){
    return ipcRenderer.invoke("carga:open-folder", dir);
  }
});

4) UI ‚Äì public/carga.html

Agregar el selector de pol√≠tica y el bot√≥n ‚ÄúVer‚Äù (a la izquierda de Anular).

No cambiamos look&feel general para no romper lo acordado.

üëâ En la secci√≥n de botones, reemplazar el <section class="flex gap-3 justify-end pt-4 border-t">‚Ä¶</section> por:

<section class="flex items-center justify-between pt-4 border-t">
  <!-- Pol√≠tica de conflicto -->
  <div class="flex items-center gap-2 text-sm">
    <span class="text-slate-600">Si el archivo ya existe:</span>
    <select id="conflictPolicy" class="border rounded-md px-2 py-1 bg-white text-slate-700">
      <option value="skip">Omitir</option>
      <option value="overwrite">Sobrescribir</option>
      <option value="next">Sumar siguiente n√∫mero</option>
    </select>
  </div>

  <!-- Botonera -->
  <div class="flex gap-3">
    <button id="btnView" class="px-4 py-2 rounded-lg bg-slate-200 text-slate-800 hover:bg-slate-300 shadow-md">
      üëÅ Ver
    </button>
    <button id="btnCancel" class="px-6 py-2.5 rounded-lg font-semibold bg-red-600 text-white hover:bg-red-700 active:bg-red-800 shadow-md">
      ‚ùå Anular
    </button>
    <button id="btnProcess" class="px-6 py-2.5 rounded-lg font-semibold bg-emerald-600 text-white hover:bg-emerald-700 active:bg-emerald-800 shadow-md disabled:opacity-40 disabled:cursor-not-allowed" disabled>
      ‚úÖ Procesar
    </button>
  </div>
</section>

<!-- Modal simple para "Ver" -->
<div id="viewModal" class="hidden fixed inset-0 bg-black/30 z-50 items-center justify-center">
  <div class="bg-white rounded-xl shadow-xl w-[min(800px,92vw)] max-h-[80vh] overflow-hidden">
    <div class="px-4 py-3 border-b flex items-center justify-between">
      <div class="font-semibold">Contenido en destino</div>
      <button id="viewClose" class="px-2 py-1 rounded bg-slate-200 hover:bg-slate-300">Cerrar</button>
    </div>
    <div id="viewBody" class="p-4 text-sm space-y-4 overflow-auto"></div>
  </div>
</div>

5) Renderer ‚Äì src/renderer/carga.ts

Agregar:

Estado conflictPolicy: "skip"|"overwrite"|"next".

L√≥gica para ‚Äúnext‚Äù: antes de procesar, pedir nextIndex al main y recalcular nombres destino (base.ext, base-1.ext, ‚Ä¶ o base-N.ext desde el √≠ndice retornado).

‚ÄúVer‚Äù: invocar listMatching y mostrar en el modal; bot√≥n ‚ÄúAbrir carpeta‚Äù.

Asegurate de no usar export/declare global. Mantener la IIFE.

(function(){
  const API = (window as any).CargaAPI;

  type Meta = { nombre:string; extension:string; uris:string[] };
  type AddedFile = { realPath?: string; realName: string; targetName: string; valid: boolean; error?: string };
  let meta: Meta = { nombre:"", extension:"", uris:[] };
  let files: AddedFile[] = [];
  let conflictPolicy: "skip"|"overwrite"|"next" = "skip";

  // ‚Ä¶(resto de tu c√≥digo actual: refs, preventDefault global, drop, etc.)

  // NUEVOS refs
  const policySel = document.getElementById("conflictPolicy") as HTMLSelectElement;
  const btnView   = document.getElementById("btnView") as HTMLButtonElement;
  const viewModal = document.getElementById("viewModal") as HTMLDivElement;
  const viewBody  = document.getElementById("viewBody") as HTMLDivElement;
  const viewClose = document.getElementById("viewClose") as HTMLButtonElement;

  policySel?.addEventListener("change", ()=> {
    conflictPolicy = (policySel.value as any) || "skip";
  });

  // Recalcula nombres con la regla por defecto (0..N-1)
  function recomputeTargetsDefault() {
    files.forEach((f, i) => {
      const suffix = i === 0 ? "" : `-${i}`;
      f.targetName = `${meta.nombre}${suffix}.${meta.extension}`;
    });
  }

  // BOT√ìN "VER"
  btnView?.addEventListener("click", async ()=>{
    try {
      viewBody.innerHTML = `<div class="text-slate-500">Analizando destinos‚Ä¶</div>`;
      viewModal.classList.remove("hidden");
      viewModal.classList.add("flex");

      const res = await API.listMatching(meta.uris, meta.nombre, meta.extension);
      // Render
      viewBody.innerHTML = res.map((r:any) => {
        const exists = r.exists;
        const header = `<div class="font-medium">${r.dir}</div>`;
        if (!exists) {
          return `<div class="p-3 rounded bg-amber-50 border border-amber-200">
                    ${header}
                    <div class="text-amber-700 text-sm mt-1">No existe. Se crear√° al procesar.</div>
                    <div class="mt-2"><button data-open="${r.dir}" class="openDir px-3 py-1 rounded bg-slate-200 hover:bg-slate-300">Abrir carpeta</button></div>
                  </div>`;
        }
        const list = r.files.length
          ? `<ul class="list-disc pl-5 mt-2 mono">${r.files.map((f:string)=>`<li>${f}</li>`).join("")}</ul>`
          : `<div class="text-slate-500 mt-1">No hay archivos que comiencen con <span class="mono">${meta.nombre}*.${meta.extension}</span></div>`;
        return `<div class="p-3 rounded bg-slate-50 border border-slate-200">
                  ${header}
                  ${list}
                  <div class="mt-2"><button data-open="${r.dir}" class="openDir px-3 py-1 rounded bg-slate-200 hover:bg-slate-300">Abrir carpeta</button></div>
                </div>`;
      }).join("");

      // bind openDir
      viewBody.querySelectorAll<HTMLButtonElement>("button.openDir").forEach(btn=>{
        btn.onclick = async ()=> { await API.openFolder(btn.dataset.open!); };
      });
    } catch (e:any) {
      viewBody.innerHTML = `<div class="text-red-600">Error: ${e?.message || e}</div>`;
    }
  });
  viewClose?.addEventListener("click", ()=>{
    viewModal.classList.add("hidden");
    viewModal.classList.remove("flex");
  });

  // PROCESS
  btnProcess.addEventListener("click", async ()=> {
    let mode: "overwrite"|"skip" = "overwrite";
    let payloadFiles = files.filter(f => f.valid && f.realPath).map(f => ({ realPath: f.realPath!, targetName: f.targetName }));

    if (conflictPolicy === "skip") {
      mode = "skip"; // no sobreescribe; nombres por defecto
    } else if (conflictPolicy === "overwrite") {
      mode = "overwrite"; // igual que ahora; nombres por defecto
    } else if (conflictPolicy === "next") {
      // Pedir nextIndex y recalcular nombres ANTES de enviar
      const { nextIndex } = await API.getNextIndex(meta.uris, meta.nombre, meta.extension);
      // Si nextIndex === 0 -> usamos el naming est√°ndar (primero sin sufijo)
      // Si nextIndex >= 1 -> todos con sufijo empezando en nextIndex
      const renamed = files.filter(f => f.valid && f.realPath).map((f, i) => {
        let name:string;
        if (nextIndex === 0) {
          name = `${meta.nombre}${i===0 ? "" : `-${i}`}.${meta.extension}`;
        } else {
          name = `${meta.nombre}-${nextIndex + i}.${meta.extension}`;
        }
        return { realPath: f.realPath!, targetName: name };
      });
      payloadFiles = renamed;
      mode = "overwrite"; // ya no colisionan
    }

    API.process({ files: payloadFiles, mode });
  });

  // Init pinta meta (asegurando may√∫sculas sin espacios)
  API?.onInit((data: Meta)=>{
    meta = data;
    document.getElementById("nombre")!.textContent = meta.nombre;
    document.getElementById("ext")!.textContent = (meta.extension || "").toUpperCase().trim();
    const urisEl = document.getElementById("uris")!;
    urisEl.innerHTML = "";
    meta.uris.forEach((u, i) => {
      const li = document.createElement("li");
      li.textContent = (i===0? "[OBLIGATORIA] ":"") + u;
      urisEl.appendChild(li);
    });
  });

  // Al agregar archivos manualmente, conservar recompute por defecto
  function addDropped(file: File & { path?: string }) {
    const realPath = (file as any).path;
    const realName = file.name;
    const ext = realName.split(".").pop()?.toLowerCase() || "";
    const valid = !!meta.extension && ext === meta.extension.toLowerCase();
    const error = valid ? undefined : `Extensi√≥n .${ext} ‚â† .${meta.extension}`;
    files.push({ realPath, realName, targetName: "", valid, error });
    recomputeTargetsDefault();
    refreshTable();
  }

  // ‚Ä¶(dej√° el resto igual: dropzone, refreshTable, borrar fila, onDone/onError, etc.)
})();