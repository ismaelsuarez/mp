Objetivo

Arreglar la VENTANA=carga para que:

Renderice los metadatos (NOMBRE, EXTENSIÓN, URIs).

Permita arrastrar archivos (drag&drop) y listarlos.

Ignore URIs vacías del .txt.

Mantenga la secuencia actual (watcher .txt → parseo → abrir ventana) sin crear watchers nuevos ni tocar contingencia.

Los síntomas actuales provienen de dos cosas:

El preload no expone window.CargaAPI a tiempo o con ruta incorrecta.

El renderer crashea / no recibe el init y además el drag está bloqueado por el default del documento (Electron navega al archivo si no se previene en document).

Aplicar los siguientes patches mínimos.

1) Preload cargado con ruta robusta (dev/packaged)

Archivo: src/main/windows/cargaWindow.ts
Cambios:

Resolver preload con base robusta y loguear la ruta.

sandbox:false (para obtener File.path en el drop).

(Opcional) abrir DevTools para ver la consola del renderer cuando debug.

// al principio del file
import fs from "fs";
import path from "path";
import { app, BrowserWindow, ipcMain } from "electron";

function getBase() {
  return app.isPackaged ? process.resourcesPath : app.getAppPath();
}

export function openCargaWindow(opts: { txtPath: string; parsed: { nombre:string; extension:string; uris:string[] } }) {
  return new Promise<void>(async (resolve) => {
    const base = getBase();
    const preloadPath = path.join(base, "dist", "src", "preload", "carga.preload.js");
    console.log("[carga] preload:", preloadPath, "exists:", fs.existsSync(preloadPath));

    const win = new BrowserWindow({
      width: 900, height: 620, show: false, frame: true,
      webPreferences: {
        preload: preloadPath,
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: false
      }
    });

    // win.webContents.openDevTools({ mode: "detach" }); // <- descomentar si querés

    // cargar html
    const htmlPath = path.join(base, "public", "carga.html");
    await win.loadFile(htmlPath);

    // handshake: si el renderer no pide init en 1200ms, lo empujamos nosotros
    let initPushed = false;
    const pushInit = () => {
      if (!initPushed && !win.isDestroyed()) {
        win.webContents.send("carga:init", opts.parsed);
        initPushed = true;
        console.log("[carga] init enviado por push");
      }
    };
    setTimeout(pushInit, 1200);

    ipcMain.once("carga:request-init", (e) => {
      if (initPushed) return;
      e.reply("carga:init", opts.parsed);
      initPushed = true;
      console.log("[carga] init respondido por request");
    });

    ipcMain.once("carga:cancel", async () => {
      try { await fs.promises.unlink(opts.txtPath); } catch {}
      if (!win.isDestroyed()) win.close();
      resolve();
    });

    ipcMain.once("carga:process", async (_event, files: { realPath: string; targetName: string }[]) => {
      try {
        const { processFilesToUris } = await import("../../services/carga/CargaProcessor");
        await processFilesToUris(files, opts.parsed.uris);
        try { await fs.promises.unlink(opts.txtPath); } catch {}
        win.webContents.send("carga:done", { ok: true, ms: 2000 });
      } catch (err: any) {
        win.webContents.send("carga:error", { message: err?.message || String(err) });
      }
    });

    win.once("ready-to-show", () => { win.show(); win.focus(); });
    win.on("closed", () => resolve());
  });
}

2) Preload expone la API y log de arranque

Archivo: src/preload/carga.preload.ts
Cambios:

Agregar log de inicio.

Exponer API sin importar objetos no permitidos (dialog, etc.).

import { contextBridge, ipcRenderer } from "electron";

console.log("[carga.preload] iniciado");

contextBridge.exposeInMainWorld("CargaAPI", {
  requestInit(){ ipcRenderer.send("carga:request-init"); },
  onInit(cb:(d:any)=>void){ ipcRenderer.on("carga:init", (_e,d)=>cb(d)); },
  cancel(){ ipcRenderer.send("carga:cancel"); },
  process(files:{realPath:string; targetName:string}[]){ ipcRenderer.send("carga:process", files); },
  onDone(cb:(p:{ok:boolean; ms:number})=>void){ ipcRenderer.on("carga:done", (_e,d)=>cb(d)); },
  onError(cb:(p:{message:string})=>void){ ipcRenderer.on("carga:error", (_e,d)=>cb(d)); },
});


Asegurate que compile a: dist/src/preload/carga.preload.js.
Si no, incluí el path en tsconfig.json o importalo desde algún sitio.

3) Renderer sin export {} y con drag desbloqueado

Archivo: src/renderer/carga.ts
Cambios clave:

No uses declare global ni export.

Agregá escuchas a nivel documento para dragover y drop con preventDefault().
(Si no están, Electron intenta navegar al archivo y bloquea el drop).

Guardas por si CargaAPI tarda en estar disponible.

// Nada de "export" ni "declare global"

type Meta = { nombre:string; extension:string; uris:string[] };
type AddedFile = { realPath?: string; realName: string; targetName: string; valid: boolean; error?: string };

(function(){
  const API = (window as any).CargaAPI;

  let meta: Meta = { nombre:"", extension:"", uris:[] };
  let files: AddedFile[] = [];

  // ***** Desbloquear drag & drop a nivel documento *****
  ["dragenter","dragover","dragleave","drop"].forEach(ev => {
    document.addEventListener(ev, (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  });

  const nombreEl = document.getElementById("nombre")!;
  const extEl = document.getElementById("ext")!;
  const urisEl = document.getElementById("uris")!;
  const dropzone = document.getElementById("dropzone")!;
  const fileInput = document.getElementById("fileInput") as HTMLInputElement;
  const filesBody = document.getElementById("filesBody")!;
  const tableEmpty = document.getElementById("tableEmpty")!;
  const btnCancel = document.getElementById("btnCancel")!;
  const btnProcess = document.getElementById("btnProcess")!;
  const okOverlay = document.getElementById("okOverlay")! as HTMLDivElement;

  function recomputeTargets() {
    files.forEach((f, i) => {
      const suffix = i === 0 ? "" : `-${i}`;
      f.targetName = `${meta.nombre}${suffix}.${meta.extension}`;
    });
  }

  function refreshTable() {
    filesBody.innerHTML = "";
    if (files.length === 0) {
      tableEmpty.style.display = "block";
      btnProcess.setAttribute("disabled","true");
      return;
    }
    tableEmpty.style.display = "none";
    btnProcess.toggleAttribute("disabled", !files.every(f => f.valid));

    files.forEach((f, idx) => {
      const tr = document.createElement("tr");
      tr.className = "border-b";
      const tdReal = document.createElement("td");
      tdReal.className = "py-2 mono";
      tdReal.textContent = f.realName + (f.error ? `  [${f.error}]` : "");
      if (f.error) tdReal.classList.add("text-red-600");

      const tdTarget = document.createElement("td");
      tdTarget.className = "py-2 mono";
      tdTarget.textContent = f.targetName;

      const tdDel = document.createElement("td");
      tdDel.className = "py-2";
      const btn = document.createElement("button");
      btn.className = "px-2 py-1 rounded bg-slate-200 hover:bg-slate-300";
      btn.textContent = "borrar";
      btn.onclick = () => { files.splice(idx,1); recomputeTargets(); refreshTable(); };
      tdDel.appendChild(btn);

      tr.appendChild(tdReal); tr.appendChild(tdTarget); tr.appendChild(tdDel);
      filesBody.appendChild(tr);
    });
  }

  function addDropped(file: File & { path?: string }) {
    const realPath = (file as any).path;   // Electron agrega .path
    const realName = file.name;
    const ext = realName.split(".").pop()?.toLowerCase() || "";
    const valid = !!meta.extension && ext === meta.extension.toLowerCase();
    const error = valid ? undefined : `Extensión .${ext} ≠ .${meta.extension}`;
    files.push({ realPath, realName, targetName: "", valid, error });
    recomputeTargets();
  }

  function handleFilesList(list: FileList) {
    for (let i=0;i<list.length;i++) addDropped(list[i] as any);
    refreshTable();
  }

  dropzone.addEventListener("click", ()=> fileInput.click());
  fileInput.addEventListener("change", ()=> { if (fileInput.files) handleFilesList(fileInput.files); });

  dropzone.addEventListener("dragenter", ()=> dropzone.classList.add("dragover"));
  dropzone.addEventListener("dragleave", ()=> dropzone.classList.remove("dragover"));
  dropzone.addEventListener("dragover", ()=> dropzone.classList.add("dragover"));
  dropzone.addEventListener("drop", (e) => {
    dropzone.classList.remove("dragover");
    const dt = e.dataTransfer;
    if (!dt) return;
    if (dt.files) handleFilesList(dt.files);
  });

  btnCancel.addEventListener("click", ()=> API?.cancel());
  btnProcess.addEventListener("click", ()=> {
    const payload = files.filter(f => f.valid && f.realPath).map(f => ({
      realPath: f.realPath!, targetName: f.targetName
    }));
    API?.process(payload);
  });

  API?.onDone(({ok, ms}:{ok:boolean; ms:number})=>{
    if (!ok) return;
    okOverlay.style.display = "flex";
    setTimeout(()=> window.close(), ms);
  });
  API?.onError(({message}:{message:string})=> alert("Error al procesar: " + message));

  API?.onInit((data: Meta)=>{
    meta = data;
    // pintar meta
    nombreEl.textContent = meta.nombre;
    extEl.textContent = meta.extension;
    urisEl.innerHTML = "";
    meta.uris.forEach((u, i) => {
      const li = document.createElement("li");
      li.textContent = (i===0? "[OBLIGATORIA] ":"") + u;
      urisEl.appendChild(li);
    });
  });

  window.addEventListener("DOMContentLoaded", ()=> {
    console.log("[carga.renderer] DOM listo; solicitando init…");
    API?.requestInit(); // si no llega, el main hará pushInit()
  });
})();

4) Parser ignora URIs vacías y soporta NOMBRE: sin espacios

Archivo: src/services/carga/CargaParser.ts
Cambios:

import fs from "fs/promises";

export type CargaData = { nombre:string; extension:string; uris:string[] };

export async function parseCargaTxt(txtPath: string): Promise<CargaData> {
  const raw = await fs.readFile(txtPath, "utf8");
  const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  let nombre = "", extension = "";
  const uris: string[] = [];

  for (const line of lines) {
    if (/^NOMBRE\s*:/i.test(line)) {
      nombre = (line.split(":")[1] ?? "").trim();
    } else if (/^EXTENSION\s*:/i.test(line)) {
      extension = (line.split(":")[1] ?? "").trim().replace(/^\./,"").toLowerCase();
    } else if (/^URI\s*=/i.test(line)) {
      const v = (line.split("=")[1] ?? "").trim();
      if (v) uris.push(v); // <-- ignorar vacías
    }
  }

  if (!nombre) throw new Error("Falta NOMBRE:");
  if (!extension) throw new Error("Falta EXTENSION:");
  if (uris.length === 0) throw new Error("Debe venir al menos un URI=");

  nombre = nombre.replace(/[\\/:*?"<>|]/g, "_"); // sanitizar
  return { nombre, extension, uris };
}

5) HTML: sin cambios de estructura (solo asegúrate del script)

En public/carga.html dejá el script al final no-module (ya que el renderer no exporta nada):

<script src="../dist/src/renderer/carga.js"></script>
</body>
</html>


(Si estabas inyectando el JS por executeJavaScript, podés mantenerlo, pero no es necesario si el <script> funciona con la ruta correcta.)

6) Pruebas rápidas

Lanzar app y forzar apertura con tu carga162918.txt adjunto.

Ver en consola:

[carga.preload] iniciado

[carga] init respondido por request o [carga] init enviado por push

La ventana debe mostrar:

NOMBRE: A0002-00000255

EXTENSIÓN: pdf

URIs: solo C:\correo\administracion\EMPRESAS\AX\FACTURAS\00059-INYCO S.A (las vacías se ignoran)

Arrastrar un .pdf → aparece en la tabla:

A0002-00000255.pdf, A0002-00000255-1.pdf, …

Procesar debe copiar a la(s) URI(s) y mostrar OK 2s.

Notas

Si aún no aparece File.path durante el drop, estamos en una build donde Electron oculta la ruta. Plan B: agregar en el preload una función que abra showOpenDialog como fallback (te lo preparo si hace falta).

Este fix no toca el watcher ni el flujo principal; solo asegura handshake IPC, renderer sin “export {}” y drag desbloqueado.