You are an expert Electron + React/TypeScript engineer working inside this repository.

TASK: Diagnose and fix the “Caja mode → Logs/Console” view that sometimes fails to live-refresh (stalls or only updates after closing/reopening the app). This occurs on two client workstations but not on others.

SCOPE & GOALS
1) Identify the log data source and path:
   - Is it streaming via Electron IPC (ipcMain/ipcRenderer), WebSocket/EventSource, Node child_process stdout, or tailing a log file (e.g., chokidar/fs.watch)?
   - Map the flow: producer → transport (IPC/ws/file) → state/store → UI component(s).
2) Reproduce and measure:
   - Add lightweight instrumentation: timestamps, event counters, dropped-events counter, last-render time, queue size, backpressure, reconnection attempts.
   - Provide a simple CLI script to generate high-frequency log events for reproducible stress tests.
3) Diagnose likely root causes (check all):
   - Electron/Chromium background throttling (BrowserWindow.webPreferences / backgroundThrottling).
   - React effect dependencies or stale closures preventing state updates.
   - Over-aggressive debounce/throttle, requestAnimationFrame timing, or setInterval clamping when window is not focused.
   - Virtualized list auto-scroll bugs (locked scroll at bottom), large DOM, or heavy re-renders blocking the UI thread.
   - Stream paused or buffer not flushed (Node streams ‘data’ events, highWaterMark, backpressure).
   - File watcher edge cases (network drives, antivirus). Fallback to polling (chokidar usePolling).
   - IPC handler leaks or missing cleanup (multiple subscriptions on re-mount).
   - Env-specific differences (OS, Node/Electron versions, GPU/hardware acceleration).
4) Implement robust live updates + resilience:
   - Ensure BrowserWindow has backgroundThrottling: false (if appropriate).
   - Normalize transport to a single stream abstraction (EventEmitter or RxJS observable) with:
     • Live mode (follow/tail), Pause, and Manual Refresh.
     • Auto-reconnect with exponential backoff when no events arrive for N seconds but the producer is alive.
     • Health indicator (LIVE / STALLED / RECONNECTING) + counters (events/sec, last event ts).
   - In React:
     • Subscribe in useEffect with proper cleanup; no stale closures. Memoize selectors.
     • Keep UI responsive: minimal state, batched updates (e.g., push to ring buffer, render on rAF or short interval).
     • Implement auto-scroll that follows only when the user is at bottom; if user scrolls up, pause following.
   - For file-based logs:
     • Use chokidar with fallback: { usePolling: true, interval: 1000 } if native watchers are unreliable on certain machines.
     • Handle partial lines and flush logic clearly.
   - For IPC/WebSocket:
     • Add ping/heartbeat; detect silent disconnects; re-subscribe cleanly on renderer reload.
5) Add a minimal UI to the Logs/Console panel:
   - Controls: [Live] [Pause] [Retry] [Clear].
   - Status pill with LIVE/PAUSED/RECONNECTING/STALLED + counters (events, events/sec, last event timestamp).
   - Optional filter input and “tail from latest” toggle.
6) Environment diagnostics panel (hidden behind a small “i” icon):
   - OS, Electron, Node versions, GPU status, hardwareAcceleration, backgroundThrottling value, watcher mode (native vs polling), transport type, buffer sizes.
7) Tests & validation:
   - Unit tests for the stream adapter (buffering, pause/resume, reconnection).
   - E2E (Playwright) scenario: produce logs at varying rates, switch window focus/unfocus, verify the UI keeps updating; test auto-scroll behavior.
   - Side-by-side test on one “affected” and one “healthy” machine; collect a brief comparison report (timers clamped? watcher fallback engaged? GPU off?).
8) Deliverables:
   - PR with:
     • Code changes (stream adapter, UI controls, diagnostics).
     • A “LOGS_TROUBLESHOOTING.md” with architecture diagram, common failure modes, and how to switch watcher polling.
     • Scripts: `scripts/dev:log-storm` (simulated logs) and a one-shot env dump.
     • A “CHECKLIST.md” (acceptance criteria below).
9) Non-regressions:
   - No .env changes required.
   - Keep current visual design; only add minimal controls and status.
   - Maintain performance with large volumes (use ring buffer and batch rendering).

IMPLEMENTATION HINTS (adjust to repo):
- Electron:
  const win = new BrowserWindow({ webPreferences: { backgroundThrottling: false, /* keep existing */ }});
- Chokidar fallback:
  const watcher = chokidar.watch(file, { ignoreInitial: false, awaitWriteFinish: true, usePolling: fallbackFlag, interval: 1000 });
- Stream adapter:
  Expose a single subscribe(fn) API; internally handle IPC/ws/file, buffering, backoff, and heartbeat.
- React:
  useEffect(() => { const unsub = stream.subscribe(enqueue); return () => unsub(); }, []);
  Keep a ring buffer (e.g., 5k lines). Render batches on rAF or short setTimeout to prevent blocking.
- Auto-scroll logic:
  Follow only if near bottom; expose a “Follow” toggle; show a “New logs” badge when paused.

ACCEPTANCE CRITERIA (CHECKLIST)
[ ] Logs/Console updates live for ≥10 minutes under continuous load without stalls on affected machines.
[ ] When window loses focus or is backgrounded, updates continue (if product requirements allow).
[ ] If the stream halts for >N seconds, status changes to RECONNECTING and recovers automatically.
[ ] File watcher issues on problematic PCs auto-switch to polling and keep updating.
[ ] UI shows clear state (LIVE/PAUSED/RECONNECTING/STALLED) and counters; user can Pause/Retry/Clear.
[ ] Auto-scroll works correctly; user scrolling up pauses following; returning to bottom resumes following.
[ ] E2E test passes on both affected and unaffected environments.
[ ] No regressions in performance or memory usage (bounded buffer).

Now:
1) Locate the Caja mode Logs/Console codepath and document current data flow.
2) Implement the stream adapter + UI/status controls with minimal footprint.
3) Add instrumentation and tests.
4) Open a PR with all deliverables and a short summary of the root cause(s) and fix(es).
