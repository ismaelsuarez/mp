export type CondIvaCode = 1|4|5|6|8|9|10|13|15;
export const COND_IVA_MAP: Record<CondIvaCode,string> = {
  1:'IVA Responsable No Inscripto',
  4:'IVA Sujeto Exento',
  5:'Consumidor Final',
  6:'Responsable Monotributo',
  8:'Proveedor del Exterior',
  9:'Cliente del Exterior',
  10:'IVA Liberado - Ley 19.640',
  13:'Monotributista Social',
  15:'IVA No Alcanzado'
};
export function isCondIvaCode(x:any): x is CondIvaCode {
  return [1,4,5,6,8,9,10,13,15].includes(Number(x));
}
Extender el DTO del receptor (sin romper usos existentes):

ts
Copiar código
export interface ReceptorDTO {
  condIvaCode?: CondIvaCode;
  condIvaDesc?: string;
  docTipo: number;   // 99 CF | 80 CUIT | etc.
  docNro: number;    // 0 para CF
  // demás campos ya existentes
}
Parser .fac

En parseFac(filePath): extraer IVARECEPTOR:\s*(\d+).

Si !isCondIvaCode(code): lanzar PermanentError('IVARECEPTOR desconocido').

Setear solo para uso interno:

ts
Copiar código
dto.receptor.condIvaCode = code;
dto.receptor.condIvaDesc = COND_IVA_MAP[code];
No agregar nada al PDF ni al .res.

Normalización de documento del receptor (uso interno)

Si condIvaCode === 5 (Consumidor Final):

Para el FECAEReq forzar docTipo=99 y docNro=0 (aunque el .fac traiga otra cosa). Registrar en auditoría interna si se normaliza.

Si condIvaCode !== 5:

Exigir documento válido (p.ej. docTipo=80 y docNro ≠ 0). Si falta o es inválido: PermanentError('Documento receptor inválido para la condición IVA').

Reglas por tipo de comprobante (A/B/C) — solo validación interna

Implementar validateReceptorVsCbte(dto) y llamarla en la fase VALIDATE:

Factura A: rechazar condIvaCode ∈ {5,4,6,13,15} → PermanentError('IVARECEPTOR incompatible con Tipo A').

Factura B: permitir {5,4,6,13,15}; rechazar condiciones que requieran A (p.ej. 1 RI) → PermanentError('Receptor requiere Tipo A').

Factura C: solo si el emisor es monotributista (flag existente). Si no: PermanentError('Emisor no monotributista no puede emitir C').

Exterior (8/9) y 10 (Ley 19.640): dejar no soportados por ahora → PermanentError con mensaje claro.

Ante error permanente, usar el flujo actual de .res (misma firma y formato). No modificar el contenido generado.

Armado del FECAEReq (único cambio funcional)

En buildFECAEReq(dto):

Si condIvaCode === 5 → usar DocTipo=99, DocNro=0.

Caso contrario → usar el documento validado del DTO.

IVA:

A/B/M con emisor no monotributista → construir AlicIva[] por alícuota y ImpIVA = suma(Importe).

C con emisor monotributista → no enviar AlicIva[] y ImpIVA = 0.

Verificar identidad:
ImpTotal = ImpNeto + ImpIVA + ImpTrib + ImpTotConc + ImpOpEx (redondeo 2 decimales).
Si no cierra → PermanentError('Totales no cierran').

Logs y auditoría (internos)

Log estructurado al emitir:
{ cbteTipo, condIvaCode, condIvaDesc, docTipoFE, docNroFE, ivaSummary }.

Guardar auditoría interna (DB/archivo). No alterar el .res.

Tests (Vitest) — no validar PDF ni .res

Parser: IVARECEPTOR válido / inválido.

A: condIvaCode=1 + CUIT válido → OK; condIvaCode=5 → PermanentError('IVARECEPTOR incompatible con Tipo A').

B: condIvaCode=5 (aunque el .fac traiga otro doc) → FECAEReq con DocTipo=99 y DocNro=0.
condIvaCode=1 → PermanentError('Receptor requiere Tipo A').

C (emisor MT): condIvaCode=5 → FECAEReq sin AlicIva[] y ImpIVA=0.

Identidad de totales: assert matemático.

Asegurar que generatePdf(...) y generateRes(...) se invocan con la misma firma de hoy (spies), sin inspeccionar su contenido.

Compatibilidad

No leer .env nuevos.

No tocar src/pdf/** ni src/res/**.

Mantener la regla del pipeline: borrar .fac solo tras CAE_OK + PDF_OK + RES_OK.

CRITERIOS DE ACEPTACIÓN (manuales)

.fac B con IVARECEPTOR:5 (CF) → FECAEReq usa 99/0, AFIP acepta, y PDF/.res salen igual que hoy.

.fac A con receptor RI (1) → acepta; A con CF (5) → corta con error permanente (mismo .res de siempre).

.fac C (emisor MT) → sin AlicIva[] y ImpIVA=0.

En ningún caso se modifican contenidos de PDF ni .res.